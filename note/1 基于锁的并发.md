# 并发控制：锁与安全访问

这份笔记探讨了在多线程编程中，如何通过**锁（Lock）**来管理共享资源，避免数据不一致的问题，并进一步讨论了更安全的并发控制机制。

### 锁的 API

- **`Lock.acquire（）`**： **阻塞**当前线程，直到成功获取到锁。
- **`Lock.try_acquire（）`**： 尝试获取锁。 如果锁已被占用，则**立即返回 `false` 且不阻塞**; 如果成功获取，则返回 。`true`
- **`Lock.release（）`**： 释放已获取的锁。

### 符号说明

- `||`： 表示隔离不同的**线程**。
- `X`： 表示**共享资源**，初始值为 。`0`
- `r1`， ： 表示**线程各自的寄存器**。`r2`
- `L`： 表示**互斥锁（Mutex Lock）**。

### 未加锁

```bash
r1=X || r2=X
X=r1+1 || X=r2+1
```

**过程**： 两个线程**同时**进行作(将 的值读入各自的寄存器,然后将各自寄存器的值加 并写回 ). 它们之间互不干涉.

**结果**： 的最终值是**不确定**的. 这可能导致**写入覆盖(Write Overwrite)**,从而产生错误的结果,最终可能是 1 或者 2

### 加锁后的情况

```bash
L.acquire() || L.acquire()
r1=X || r2=X
X=r1+1 || X=r2+1
L.release() || L.release()
```

**过程**： 两个线程的作业轮流进行. 一个线程必须先获取锁(`L.acquire()`)才能读写 `X`. 完成作后,该线程释放锁(`L.release()`),另一个线程才能有机会获取锁并执行作.

## 自动管理锁的生命周期

考虑到手动释放锁容易出错（例如忘记释放或重复释放），引入了**自动获取和释放锁**的概念，旨在提升代码安全性和开发效率。

### `LockGuard` （C++ RAII 风格）

`LockGuard` 是一种基于 C++ RAII（Resource Acquisition Is Initialization）思想的设计模式。 它确保当一个对象被创建时（资源被获取），其析构函数在对象生命周期结束时自动执行（资源被释放）。

- **优点**： 极大简化了锁的管理，降低了手动释放锁带来的错误风险。
- **潜在问题**： 即使使用了 ，如果获取了受保护资源的**指针或引用**，并在 对象（即锁）**自动销毁后**通过这个指针/引用去修改数据，仍然会发生**数据竞争**，导致问题。 这是因为 只保证了代码块内部的互斥访问，但并不能阻止对外部泄露的指针/引用进行不安全的访问。` LockGuard``LockGuard``LockGuard `

### 更安全的方案：Rust 的并发模型

为了解决 存在的潜在指针问题，一些现代编程语言（如 **Rust**）引入了更严格的所有权和生命周期管理机制。`LockGuard`

Rust 的并发模型确保了：

- **锁的生命周期必须长于任何指向受保护资源的引用**。 这意味着，只要存在对受保护资源的引用，相应的锁就必须一直被持有。
- 通过**编译时检查**，Rust 能够**强制执行这些规则**，从而在编译阶段就捕获潜在的并发错误，避免了运行时的数据竞争。

这种机制从根本上提升了并发编程的安全性，使得开发者能够编写出更健壮、无数据竞争的并发代码。
